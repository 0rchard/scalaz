package scalaz

/** Duality of functors */
trait Duality[F[_], G[_]] { self =>
  def zap[A, B, C](fa: F[A], gb: G[B])(f: (A, B) => C): C
  def smash[A, B](f: F[A => B], g: G[A]): B = zap(f, g)(_(_))
  def flip: Duality[G, F] = new Duality[G, F] {
    def zap[A, B, C](ga: G[A], fb: F[B])(f: (A, B) => C): C =
      self.zap(fb, ga)((b, a) => f(a, b))
  }
}

trait DualityInstances {

  /** The duality between the identity functor and itself. */
  val identityDuality: Duality[Id, Id] = new Duality[Id, Id] {
    def zap[A, B, C](a: A, b: B)(f: (A, B) => C): C = f(a, b)
  }

  /** The duality between the product and coproduct of two functors. */
  def productCoproductDuality[F[_], FF[_], G[_], GG[_]](implicit d1: Duality[F, FF], d2: Duality[G, GG]):
    Duality[({ type λ[α] = Either[F[α], G[α]] })#λ, ({ type λ[α] = (FF[α], GG[α]) })#λ] =
      new Duality[({ type λ[α] = Either[F[α], G[α]] })#λ, ({ type λ[α] = (FF[α], GG[α]) })#λ] {
        def zap[A, B, C](a: Either[F[A], G[A]], b: (FF[B], GG[B]))(f: (A, B) => C) =
          a match {
            case Left(fa) => d1.zap(fa, b._1)(f)
            case Right(ga) => d2.zap(ga, b._2)(f)
          }
      }

  /** The duality between the coproduct and product of two functors. */
  def coproductProductDuality[F[_], FF[_], G[_], GG[_]](implicit d1: Duality[FF, F], d2: Duality[GG, G]):
    Duality[({ type λ[α] = (FF[α], GG[α]) })#λ, ({ type λ[α] = Either[F[α], G[α]] })#λ] =
      new Duality[({ type λ[α] = (FF[α], GG[α]) })#λ, ({ type λ[α] = Either[F[α], G[α]] })#λ] {
        def zap[A, B, C](a: (FF[A], GG[A]), b: Either[F[B], G[B]])(f: (A, B) => C) =
          b match {
            case Left(fb) => d1.zap(a._1, fb)(f)
            case Right(gb) => d2.zap(a._2, gb)(f)
          }
      }

  /** The duality between a free monad generated by a functor and the cofree comonad generated by its dual. */
  def monadComonadDuality[F[+_], G[+_]](implicit d: Duality[F, G], F: Functor[F], G: Functor[G]):
    Duality[({type λ[α] = Free[F, α]})#λ, ({type λ[α] = Cofree[G, α]})#λ] =
      new Duality[({type λ[α] = Free[F, α]})#λ, ({type λ[α] = Cofree[G, α]})#λ] {
        def zap[A, B, C](ma: Free[F, A], wb: Cofree[G, B])(f: (A, B) => C): C =
          ma.resume match {
            case Right(a) => f(a, wb.head)
            case Left(k) => d.zap(k, wb.tail)(zap(_, _)(f))
          }
      }

  /** The duality between a cofree comonad generated by a functor and the free monad generated by its dual. */
  def comonadMonadDuality[F[+_], G[+_]](implicit d: Duality[F, G], F: Functor[F], G: Functor[G]):
    Duality[({type λ[α] = Cofree[F, α]})#λ, ({type λ[α] = Free[G, α]})#λ] =
      new Duality[({type λ[α] = Cofree[F, α]})#λ, ({type λ[α] = Free[G, α]})#λ] {
        def zap[A, B, C](wa: Cofree[F, A], mb: Free[G, B])(f: (A, B) => C): C =
          mb.resume match {
            case Right(b) => f(wa.head, b)
            case Left(k) => d.zap(wa.tail, k)(zap(_, _)(f))
          }
      }
}

object Duality extends DualityInstances 
